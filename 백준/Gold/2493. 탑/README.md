# **[Gold V] 탑 - 2493**

[문제 링크](https://www.acmicpc.net/problem/2493)

### **성능 요약**

메모리: 143308 KB, 시간: 532 ms

### **분류**

자료 구조, 스택

### **제출 일자**

2025년 10월 28일 13:54:48

### **문제 설명**

KOI 통신연구소는 레이저를 이용한 새로운 비밀 통신 시스템 개발을 위한 실험을 하고 있다. 실험을 위하여 일직선 위에 N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향으로 차례로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치하였다. 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고, 탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다. 하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다.

예를 들어 높이가 6, 9, 5, 7, 4인 다섯 개의 탑이 수평 직선에 일렬로 서 있고, 모든 탑에서는 주어진 탑 순서의 반대 방향(왼쪽 방향)으로 동시에 레이저 신호를 발사한다고 하자. 그러면, 높이가 4인 다섯 번째 탑에서 발사한 레이저 신호는 높이가 7인 네 번째 탑이 수신을 하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신을 한다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신을 하지 못한다.

탑들의 개수 N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 프로그램을 작성하라.

### **입력**

첫째 줄에 탑의 수를 나타내는 정수 N이 주어진다. N은 1 이상 500,000 이하이다. 둘째 줄에는 N개의 탑들의 높이가 직선상에 놓인 순서대로 하나의 빈칸을 사이에 두고 주어진다. 탑들의 높이는 1 이상 100,000,000 이하의 정수이다.

### **출력**

첫째 줄에 주어진 탑들의 순서대로 각각의 탑들에서 발사한 레이저 신호를 수신한 탑들의 번호를 하나의 빈칸을 사이에 두고 출력한다. 만약 레이저 신호를 수신하는 탑이 존재하지 않으면 0을 출력한다.

# 분석

## 왜 스택을 생각하지 못했는가?

- 우선순위 큐로 삽질 와장창
- [high … [high…low]…low] 구조가 반복되는 것은 인지
  - 이런 구조는 예전에 다룬 적이 있었다
  - 오큰수 문제
    - 패턴을 찾으면서 DP도 생각했지만, 맨 앞 값만 필요함을 인지하고 stack을 잘 썼다.
      <aside>
      👉
      
      ## 패턴 찾기
      
      - a1 …. a2 라면 a1의 오큰수는 a2다.
      - 그 사이의 … 는 모든 수는 a1보다 작음.
      - 이 사이의 … 에도 b1…b2 이 패턴이 반복되는 구조
      - a1 b1 c1 …c2 b2 a2 이런 형태
      - **그래서 큰 문제를 작은 문제로 쪼개는 DP를 구상**
      - 한번 seq 순회하고 앞의 정보를 저장
      
      ## 어떻게 값을 저장하느냐 → 자료구조를 활용하기
      
      - c1…c2를 재귀 형태로 반복해서 answer[c1] = c2로 바로 저장 하지만 c2로 저장해야 한다.
      - **결국 가장 맨 앞의 값을 가져다 쓰는 형태 → 스택을 활용하기**
      - **자료구조 활용 감각을 잊지말기**
      </aside>

  - high …. low 가 있다면, answer[lowIndex]는 딴거 다 필요없이 answer[highIndex]일 것
    - **가장 맨 앞의 값을 가져다 쓰는 형태**
    - 스택에 넣고 그대로 빼는 형태
    - **형태에서 스택을 쓰는 감각을 잊지 않기**

## 2️⃣ 브루트포스로 접근해보면 문제 구조가 보인다

처음엔 당연히 이렇게 생각할 거야 👇

> i번째 탑의 왼쪽으로 한 칸씩 가면서 처음으로 h[j] >= h[i]인 j를 찾자.

즉,

```jsx
for (i = 0; i < N; i++) {
  for (j = i - 1; j >= 0; j--) {
    if (h[j] >= h[i]) break;
  }
}
```

이걸 보면, **각 원소가 왼쪽 원소들을 반복적으로 확인한다**는 점이 보여.

→ 즉, 중첩 루프 (O(N²)).

이 시점에서 떠올려야 하는 생각이 있어:

> “내가 이미 왼쪽에서 어떤 것들을 확인했는데,
>
> 다음 원소에서도 또 비슷한 비교를 반복하고 있지 않나?”

이런 중복을 줄이기 위해,

“**이미 필요 없는 원소들을 저장하지 않기**” 위한 자료구조가 필요해.

그게 바로 **스택**이야.

- [6 9 4 3 2 1]가 있고 5의 탑을 찾는 것에는 뒤의 4 3 2 1 따윈 필요없고 가장 끝에 값 9만 필요함
  - 5 뒤에 올 것들에도 마찬가지, 4 3 2 1 5 이렇게 있으면 4 3 2 1은 뒤의 인덱스 비교에 아무런 도움이 되지 못함
  - stack에서 다 빼버리기

```tsx
const readline = require("readline").createInterface({
  input: process.stdin,
  output: process.stdout,
});
let n = 0,
  lineCount = 0,
  input = [],
  answer = [];
readline
  .on("line", (line) => {
    if (lineCount === 0) {
      n = Number(line.trim());
      answer = Array(n).fill(0);
      lineCount += 1;
    } else {
      input = line
        .trim()
        .split(" ")
        .map((val) => Number(val));
      readline.close();
    }
  })
  .on("close", () => {
    let stack = [];
    for (let i = 0; i < n; i++) {
      let current = input[i];
      while (stack.length > 0) {
        let front = stack[stack.length - 1];
        if (current > front.value) {
          stack.pop();
        } else {
          answer[i] = front.index;
          break;
        }
      }
      stack.push({ index: i + 1, value: current });
    }

    console.log(answer.join(" "));
  });

/**
 * 6 9 5 7 4
 * [9 7]
 */
a;
```
