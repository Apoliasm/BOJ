# **[Gold V] 합분해 - 2225**

[문제 링크](https://www.acmicpc.net/problem/2225)

### **성능 요약**

메모리: 10276 KB, 시간: 188 ms

### **분류**

수학, 다이나믹 프로그래밍

### **제출 일자**

2025년 11월 26일 16:41:31

### **문제 설명**

0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

### **입력**

첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

### **출력**

첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

# 분석

## 전형적인 DP

### 순서 바뀜에 대한 오해

- n이 되는 경우 = 모든 n-i가 되는 경우를 더하는 것
- 이게 맞다.
- 하지만 (n-i) +i랑 i+(n-i)는 다른 경우인데?
- **어차피 두번째 for 돌면서 이 다른 순서도 걸러질 것**

### 모듈러 연산

- **처음 모듈러해도, 나중에 모듈러해도, 몇번이고 모듈러해도 결과는 항상 같음을 기억하기**
- **처음 모듈러 시키고, 나중에 또하고만 기억하기**
- **(a + b) % M = ((a % M) + (b % M)) % M**
- **modulo는 몇 번을 반복해도 결과가 변하지 않는다.**

### 디테일한 문제 조건 잘 보기

- 0~n까지 → 0을 더하는 것도 포함이 되어있음을 인지
- [n-1][n-1] array를 만들면 안됨 ⇒ k가 더 클 수도 있기 때문

### 결론

- DP를 이루는 기본을 잘 고려해보기
