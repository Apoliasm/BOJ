현대자동차에서 근무하고 있는 로하는 주어진 작업 슬롯 하나로 N개의 자동차를 생산하는 공정을 계획하려 한다. 각 i번째 자동차는 생산하기 위해 si단계의 생산 프로세스를 거쳐야 한다. 작업 슬롯은 수직선상에서 [0,1)로 표현할 수 있으며, i번째 자동차 생산이 진행 중인 경우 이 중 si1 크기의 반열린 구간을 차지한다. 0초부터 시작해서 1초마다 다음과 같은 일이 순서대로 일어난다.

- 먼저 할당된 생산 프로세스부터, 작업 슬롯의 모든 생산 프로세스들은 자신의 크기만큼 뒤로 움직인다. 즉, 작업 슬롯의 전체 구간을 [0,1)로 표현했을 때, i번째 생산 프로세스가 [sij−1,sij)의 구간을 차지하고 있었다면, 이동 후 [sij,sij+1)의 구간을 차지하게 된다. 단, 이동 시 다른 생산 프로세스가 차지하는 구간과 겹치게 되는 경우에는 움직이지 않는다. 슬롯을 통과하여 [0,1) 밖으로 나온 경우 이 생산 프로세스는 완료된 것이며, 더 이상 공간을 차지하지 않는다.
- 로하는 아직 할당하지 않은 생산 프로세스 중 하나를 골라 슬롯에 할당하거나 할당하지 않을 수 있다. i번째 생산 프로세스를 할당할 경우 슬롯의 [0,si1) 부분에 생산 프로세스를 할당한다. 단, 다른 생산 프로세스가 차지하고 있는 구간과 겹치는 경우 할당할 수 없다.

모든 자동차가 작업 슬롯을 거쳐 생산될 때까지 걸리는 최소 시간이 몇 초인지 구하여라.

**노트:**

반열린구간 [a,b) 는 a 이상 b 미만의 모든 수를 포함하는 구간이다.

**제약조건
1≤N≤200000
1≤si≤200000**

**입력형식
첫 번째 줄에 생산해야 하는 자동차의 개수 N이 주어진다.
두 번째 줄에 N개의 자동차의 생산 프로세스에 대한 각각의 단계 수 s1,s2,…,sN가 공백으로 구분되어 주어진다.**

**출력형식
첫 번째 줄에, 모든 자동차가 작업 슬롯을 거쳐 끝날 때까지 걸리는 최소 시간을 초 단위로 출력한다.**

### **입력예제1**

```
4
5 7 8 11
```

### **출력예제1**

```
14
```

#

### **입력예제2**

```
1
200000
```

### **출력예제2**

```
200000
```

# 분석

- **관찰을 통해 알아내기**
  - 좀 더 빨리 알았으면 어땠을지..
  - 역시 문제를 많이 풀어보고 경험치를 쌓는게 답이다
- 문제가 복잡해 보였지만, 반드시 성립하는 어떤 명제를 찾는 문제
  - 이를 통해 추상화를 하고 알고리즘을 짤 수 있다.
    ![image.png](attachment:e92a10ab-5d2a-4b3a-88e2-e16bea7bea17:image.png)
  - 작은것 부터 넣으면 절대 겹칠 일이 없는 것을 발견함
  - 계산할 것도 없이 답이 max+ n -1 이 자명함

```tsx
const readline = require("readline");
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

let input = [];

rl.on("line", (line) => {
  input.push(
    line
      .trim()
      .split(" ")
      .map((element) => parseInt(element, 10))
  );
}).on("close", () => {
  let n = input[0][0];
  let items = [...input[1]];
  items = items.sort((a, b) => a - b);
  let minimum = items[0];
  let maximum = items[n - 1];
  let result = maximum + n - 1;
  console.log(result);
});
```
